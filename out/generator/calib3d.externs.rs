extern "C" {
	// RQDecomp3x3(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:766
	pub fn cv_RQDecomp3x3_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, mtx_r: *const c_void, mtx_q: *const c_void, qx: *const c_void, qy: *const c_void, qz: *const c_void, ocvrs_return: *mut Result<core::Vec3d>);
	// Rodrigues(cv::InputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:600
	pub fn cv_Rodrigues_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, jacobian: *const c_void, ocvrs_return: *mut Result_void);
	// calibrateCameraRO(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, int, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1674
	pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, std_deviations_obj_points: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// calibrateCameraRO(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, int, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, cv::OutputArray, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1687
	pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// calibrateCamera(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1599
	pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// calibrateCamera(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1610
	pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// calibrateHandEye(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::OutputArray, cv::OutputArray, cv::HandEyeCalibrationMethod) /usr/include/opencv2/calib3d.hpp:2197
	pub fn cv_calibrateHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_HandEyeCalibrationMethod(r_gripper2base: *const c_void, t_gripper2base: *const c_void, r_target2cam: *const c_void, t_target2cam: *const c_void, r_cam2gripper: *const c_void, t_cam2gripper: *const c_void, method: crate::calib3d::HandEyeCalibrationMethod, ocvrs_return: *mut Result_void);
	// calibrateRobotWorldHandEye(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::RobotWorldHandEyeCalibrationMethod) /usr/include/opencv2/calib3d.hpp:2340
	pub fn cv_calibrateRobotWorldHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_RobotWorldHandEyeCalibrationMethod(r_world2cam: *const c_void, t_world2cam: *const c_void, r_base2gripper: *const c_void, t_base2gripper: *const c_void, r_base2world: *const c_void, t_base2world: *const c_void, r_gripper2cam: *const c_void, t_gripper2cam: *const c_void, method: crate::calib3d::RobotWorldHandEyeCalibrationMethod, ocvrs_return: *mut Result_void);
	// calibrationMatrixValues(cv::InputArray, cv::Size, double, double, double &, double &, double &, cv::Point2d &, double &) /usr/include/opencv2/calib3d.hpp:1715
	pub fn cv_calibrationMatrixValues_const__InputArrayR_Size_double_double_doubleR_doubleR_doubleR_Point2dR_doubleR(camera_matrix: *const c_void, image_size: *const core::Size, aperture_width: f64, aperture_height: f64, fovx: *mut f64, fovy: *mut f64, focal_length: *mut f64, principal_point: *mut core::Point2d, aspect_ratio: *mut f64, ocvrs_return: *mut Result_void);
	// checkChessboard(cv::InputArray, cv::Size) /usr/include/opencv2/calib3d.hpp:1277
	pub fn cv_checkChessboard_const__InputArrayR_Size(img: *const c_void, size: *const core::Size, ocvrs_return: *mut Result<bool>);
	// composeRT(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:844
	pub fn cv_composeRT_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(rvec1: *const c_void, tvec1: *const c_void, rvec2: *const c_void, tvec2: *const c_void, rvec3: *const c_void, tvec3: *const c_void, dr3dr1: *const c_void, dr3dt1: *const c_void, dr3dr2: *const c_void, dr3dt2: *const c_void, dt3dr1: *const c_void, dt3dt1: *const c_void, dt3dr2: *const c_void, dt3dt2: *const c_void, ocvrs_return: *mut Result_void);
	// computeCorrespondEpilines(cv::InputArray, int, cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2834
	pub fn cv_computeCorrespondEpilines_const__InputArrayR_int_const__InputArrayR_const__OutputArrayR(points: *const c_void, which_image: i32, f: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
	// convertPointsFromHomogeneous(cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2365
	pub fn cv_convertPointsFromHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
	// convertPointsHomogeneous(cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2377
	pub fn cv_convertPointsHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
	// convertPointsToHomogeneous(cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2354
	pub fn cv_convertPointsToHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
	// correctMatches(cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2880
	pub fn cv_correctMatches_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(f: *const c_void, points1: *const c_void, points2: *const c_void, new_points1: *const c_void, new_points2: *const c_void, ocvrs_return: *mut Result_void);
	// decomposeEssentialMat(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2622
	pub fn cv_decomposeEssentialMat_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(e: *const c_void, r1: *const c_void, r2: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
	// decomposeHomographyMat(cv::InputArray, cv::InputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays) /usr/include/opencv2/calib3d.hpp:3245
	pub fn cv_decomposeHomographyMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(h: *const c_void, k: *const c_void, rotations: *const c_void, translations: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<i32>);
	// decomposeProjectionMatrix(cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:793
	pub fn cv_decomposeProjectionMatrix_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(proj_matrix: *const c_void, camera_matrix: *const c_void, rot_matrix: *const c_void, trans_vect: *const c_void, rot_matrix_x: *const c_void, rot_matrix_y: *const c_void, rot_matrix_z: *const c_void, euler_angles: *const c_void, ocvrs_return: *mut Result_void);
	// drawChessboardCorners(cv::InputOutputArray, cv::Size, cv::InputArray, bool) /usr/include/opencv2/calib3d.hpp:1387
	pub fn cv_drawChessboardCorners_const__InputOutputArrayR_Size_const__InputArrayR_bool(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, pattern_was_found: bool, ocvrs_return: *mut Result_void);
	// drawFrameAxes(cv::InputOutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, float, int) /usr/include/opencv2/calib3d.hpp:1406
	pub fn cv_drawFrameAxes_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_float_int(image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, length: f32, thickness: i32, ocvrs_return: *mut Result_void);
	// estimateAffine2D(cv::InputArray, cv::InputArray, cv::OutputArray, const cv::UsacParams &) /usr/include/opencv2/calib3d.hpp:3166
	pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(pts1: *const c_void, pts2: *const c_void, inliers: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
	// estimateAffine2D(cv::InputArray, cv::InputArray, cv::OutputArray, int, double, size_t, double, size_t) /usr/include/opencv2/calib3d.hpp:3160
	pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_size_t_double_size_t(from: *const c_void, to: *const c_void, inliers: *const c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t, ocvrs_return: *mut Result<*mut c_void>);
	// estimateAffine3D(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double, double) /usr/include/opencv2/calib3d.hpp:3020
	pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ransac_threshold: f64, confidence: f64, ocvrs_return: *mut Result<i32>);
	// estimateAffine3D(cv::InputArray, cv::InputArray, double *, bool) /usr/include/opencv2/calib3d.hpp:3048
	pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_doubleX_bool(src: *const c_void, dst: *const c_void, scale: *mut f64, force_rotation: bool, ocvrs_return: *mut Result<*mut c_void>);
	// estimateAffinePartial2D(cv::InputArray, cv::InputArray, cv::OutputArray, int, double, size_t, double, size_t) /usr/include/opencv2/calib3d.hpp:3212
	pub fn cv_estimateAffinePartial2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_size_t_double_size_t(from: *const c_void, to: *const c_void, inliers: *const c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t, ocvrs_return: *mut Result<*mut c_void>);
	// estimateChessboardSharpness(cv::InputArray, cv::Size, cv::InputArray, float, bool, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:1367
	pub fn cv_estimateChessboardSharpness_const__InputArrayR_Size_const__InputArrayR_float_bool_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, rise_distance: f32, vertical: bool, sharpness: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
	// estimateTranslation3D(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double, double) /usr/include/opencv2/calib3d.hpp:3094
	pub fn cv_estimateTranslation3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ransac_threshold: f64, confidence: f64, ocvrs_return: *mut Result<i32>);
	// filterHomographyDecompByVisibleRefpoints(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArray, cv::InputArray, cv::OutputArray, cv::InputArray) /usr/include/opencv2/calib3d.hpp:3269
	pub fn cv_filterHomographyDecompByVisibleRefpoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(rotations: *const c_void, normals: *const c_void, before_points: *const c_void, after_points: *const c_void, possible_solutions: *const c_void, points_mask: *const c_void, ocvrs_return: *mut Result_void);
	// filterSpeckles(cv::InputOutputArray, double, int, double, cv::InputOutputArray) /usr/include/opencv2/calib3d.hpp:2895
	pub fn cv_filterSpeckles_const__InputOutputArrayR_double_int_double_const__InputOutputArrayR(img: *const c_void, new_val: f64, max_speckle_size: i32, max_diff: f64, buf: *const c_void, ocvrs_return: *mut Result_void);
	// find4QuadCornerSubpix(cv::InputArray, cv::InputOutputArray, cv::Size) /usr/include/opencv2/calib3d.hpp:1373
	pub fn cv_find4QuadCornerSubpix_const__InputArrayR_const__InputOutputArrayR_Size(img: *const c_void, corners: *const c_void, region_size: *const core::Size, ocvrs_return: *mut Result<bool>);
	// findChessboardCornersSB(cv::InputArray, cv::Size, cv::OutputArray, int) /usr/include/opencv2/calib3d.hpp:1334
	pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR_int(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
	// findChessboardCornersSB(cv::InputArray, cv::Size, cv::OutputArray, int, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:1330
	pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR_int_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, meta: *const c_void, ocvrs_return: *mut Result<bool>);
	// findChessboardCorners(cv::InputArray, cv::Size, cv::OutputArray, int) /usr/include/opencv2/calib3d.hpp:1270
	pub fn cv_findChessboardCorners_const__InputArrayR_Size_const__OutputArrayR_int(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
	// findCirclesGrid(cv::InputArray, cv::Size, cv::OutputArray, int, const Ptr<cv::FeatureDetector> &) /usr/include/opencv2/calib3d.hpp:1479
	pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR_int_const_Ptr_Feature2D_R(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, flags: i32, blob_detector: *const c_void, ocvrs_return: *mut Result<bool>);
	// findCirclesGrid(cv::InputArray, cv::Size, cv::OutputArray, int, const Ptr<cv::FeatureDetector> &, const cv::CirclesGridFinderParameters &) /usr/include/opencv2/calib3d.hpp:1473
	pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR_int_const_Ptr_Feature2D_R_const_CirclesGridFinderParametersR(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, flags: i32, blob_detector: *const c_void, parameters: *const crate::calib3d::CirclesGridFinderParameters, ocvrs_return: *mut Result<bool>);
	// findEssentialMat(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, const cv::UsacParams &) /usr/include/opencv2/calib3d.hpp:2599
	pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, camera_matrix2: *const c_void, dist_coeff1: *const c_void, dist_coeff2: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
	// findEssentialMat(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, int, double, double, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2591
	pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findEssentialMat(cv::InputArray, cv::InputArray, cv::InputArray, int, double, double, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2492
	pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findEssentialMat(cv::InputArray, cv::InputArray, cv::InputArray, int, double, double, int, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2483
	pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, method: i32, prob: f64, threshold: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findEssentialMat(cv::InputArray, cv::InputArray, double, cv::Point2d, int, double, double, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2540
	pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_double_Point2d_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findEssentialMat(cv::InputArray, cv::InputArray, double, cv::Point2d, int, double, double, int, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2530
	pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_double_Point2d_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findFundamentalMat(cv::InputArray, cv::InputArray, cv::OutputArray, const cv::UsacParams &) /usr/include/opencv2/calib3d.hpp:2446
	pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(points1: *const c_void, points2: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
	// findFundamentalMat(cv::InputArray, cv::InputArray, cv::OutputArray, int, double, double) /usr/include/opencv2/calib3d.hpp:2441
	pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_double(points1: *const c_void, points2: *const c_void, mask: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, ocvrs_return: *mut Result<*mut c_void>);
	// findFundamentalMat(cv::InputArray, cv::InputArray, int, double, double, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2435
	pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findFundamentalMat(cv::InputArray, cv::InputArray, int, double, double, int, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2430
	pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
	// findHomography(cv::InputArray, cv::InputArray, cv::OutputArray, const cv::UsacParams &) /usr/include/opencv2/calib3d.hpp:744
	pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
	// findHomography(cv::InputArray, cv::InputArray, cv::OutputArray, int, double) /usr/include/opencv2/calib3d.hpp:740
	pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, method: i32, ransac_reproj_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
	// findHomography(cv::InputArray, cv::InputArray, int, double, cv::OutputArray, const int, const double) /usr/include/opencv2/calib3d.hpp:734
	pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_int_double_const__OutputArrayR_const_int_const_double(src_points: *const c_void, dst_points: *const c_void, method: i32, ransac_reproj_threshold: f64, mask: *const c_void, max_iters: i32, confidence: f64, ocvrs_return: *mut Result<*mut c_void>);
	// calibrate(cv::InputArrayOfArrays, cv::InputArrayOfArrays, const cv::Size &, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:3924
	pub fn cv_fisheye_calibrate_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, k: *const c_void, d: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// distortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, double) /usr/include/opencv2/calib3d.hpp:3807
	pub fn cv_fisheye_distortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_double(undistorted: *const c_void, distorted: *const c_void, k: *const c_void, d: *const c_void, alpha: f64, ocvrs_return: *mut Result_void);
	// estimateNewCameraMatrixForUndistortRectify(cv::InputArray, cv::InputArray, const cv::Size &, cv::InputArray, cv::OutputArray, double, const cv::Size &, double) /usr/include/opencv2/calib3d.hpp:3886
	pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__OutputArrayR_double_const_SizeR_double(k: *const c_void, d: *const c_void, image_size: *const core::Size, r: *const c_void, p: *const c_void, balance: f64, new_size: *const core::Size, fov_scale: f64, ocvrs_return: *mut Result_void);
	// initUndistortRectifyMap(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, const cv::Size &, int, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:3839
	pub fn cv_fisheye_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR(k: *const c_void, d: *const c_void, r: *const c_void, p: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
	// projectPoints(cv::InputArray, cv::OutputArray, const cv::Affine3d &, cv::InputArray, cv::InputArray, double, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:3788
	pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const_Affine3dR_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, affine: *const core::Affine3d, k: *const c_void, d: *const c_void, alpha: f64, jacobian: *const c_void, ocvrs_return: *mut Result_void);
	// projectPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, double, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:3792
	pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, d: *const c_void, alpha: f64, jacobian: *const c_void, ocvrs_return: *mut Result_void);
	// stereoCalibrate(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputOutputArray, cv::InputOutputArray, cv::InputOutputArray, cv::InputOutputArray, cv::Size, cv::OutputArray, cv::OutputArray, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:3994
	pub fn cv_fisheye_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// stereoRectify(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, const cv::Size &, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, const cv::Size &, double, double) /usr/include/opencv2/calib3d.hpp:3958
	pub fn cv_fisheye_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_SizeR_double_double(k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, tvec: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, new_image_size: *const core::Size, balance: f64, fov_scale: f64, ocvrs_return: *mut Result_void);
	// undistortImage(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, const cv::Size &) /usr/include/opencv2/calib3d.hpp:3870
	pub fn cv_fisheye_undistortImage_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, knew: *const c_void, new_size: *const core::Size, ocvrs_return: *mut Result_void);
	// undistortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:3821
	pub fn cv_fisheye_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, r: *const c_void, p: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
	// getDefaultNewCameraMatrix(cv::InputArray, cv::Size, bool) /usr/include/opencv2/calib3d.hpp:3673
	pub fn cv_getDefaultNewCameraMatrix_const__InputArrayR_Size_bool(camera_matrix: *const c_void, imgsize: *const core::Size, center_principal_point: bool, ocvrs_return: *mut Result<*mut c_void>);
	// getOptimalNewCameraMatrix(cv::InputArray, cv::InputArray, cv::Size, double, cv::Size, cv::Rect *, bool) /usr/include/opencv2/calib3d.hpp:2046
	pub fn cv_getOptimalNewCameraMatrix_const__InputArrayR_const__InputArrayR_Size_double_Size_RectX_bool(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, alpha: f64, new_img_size: *const core::Size, valid_pix_roi: *mut core::Rect, center_principal_point: bool, ocvrs_return: *mut Result<*mut c_void>);
	// getValidDisparityROI(cv::Rect, cv::Rect, int, int, int) /usr/include/opencv2/calib3d.hpp:2900
	pub fn cv_getValidDisparityROI_Rect_Rect_int_int_int(roi1: *const core::Rect, roi2: *const core::Rect, min_disparity: i32, number_of_disparities: i32, block_size: i32, ocvrs_return: *mut Result<core::Rect>);
	// initCameraMatrix2D(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, double) /usr/include/opencv2/calib3d.hpp:1215
	pub fn cv_initCameraMatrix2D_const__InputArrayR_const__InputArrayR_Size_double(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, aspect_ratio: f64, ocvrs_return: *mut Result<*mut c_void>);
	// initInverseRectificationMap(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, const cv::Size &, int, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:3630
	pub fn cv_initInverseRectificationMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, new_camera_matrix: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
	// initUndistortRectifyMap(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::Size, int, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:3559
	pub fn cv_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, new_camera_matrix: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
	// initWideAngleProjMap(cv::InputArray, cv::InputArray, cv::Size, int, int, cv::OutputArray, cv::OutputArray, enum UndistortTypes, double) /usr/include/opencv2/calib3d.hpp:3636
	pub fn cv_initWideAngleProjMap_const__InputArrayR_const__InputArrayR_Size_int_int_const__OutputArrayR_const__OutputArrayR_UndistortTypes_double(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, dest_image_width: i32, m1type: i32, map1: *const c_void, map2: *const c_void, proj_type: crate::calib3d::UndistortTypes, alpha: f64, ocvrs_return: *mut Result<f32>);
	// matMulDeriv(cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:813
	pub fn cv_matMulDeriv_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(a: *const c_void, b: *const c_void, d_a_bd_a: *const c_void, d_a_bd_b: *const c_void, ocvrs_return: *mut Result_void);
	// projectPoints(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double) /usr/include/opencv2/calib3d.hpp:885
	pub fn cv_projectPoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double(object_points: *const c_void, rvec: *const c_void, tvec: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, image_points: *const c_void, jacobian: *const c_void, aspect_ratio: f64, ocvrs_return: *mut Result_void);
	// recoverPose(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, double, double, cv::InputOutputArray) /usr/include/opencv2/calib3d.hpp:2687
	pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_double_double_const__InputOutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, e: *const c_void, r: *const c_void, t: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<i32>);
	// recoverPose(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::InputOutputArray) /usr/include/opencv2/calib3d.hpp:2744
	pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<i32>);
	// recoverPose(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double, cv::InputOutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2807
	pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_const__InputOutputArrayR_const__OutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, distance_thresh: f64, mask: *const c_void, triangulated_points: *const c_void, ocvrs_return: *mut Result<i32>);
	// recoverPose(cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, double, cv::Point2d, cv::InputOutputArray) /usr/include/opencv2/calib3d.hpp:2777
	pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_Point2d_const__InputOutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, r: *const c_void, t: *const c_void, focal: f64, pp: *const core::Point2d, mask: *const c_void, ocvrs_return: *mut Result<i32>);
	// rectify3Collinear(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::Size, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, double, cv::Size, cv::Rect *, cv::Rect *, int) /usr/include/opencv2/calib3d.hpp:2009
	pub fn cv_rectify3Collinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_double_Size_RectX_RectX_int(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, camera_matrix3: *const c_void, dist_coeffs3: *const c_void, imgpt1: *const c_void, imgpt3: *const c_void, image_size: *const core::Size, r12: *const c_void, t12: *const c_void, r13: *const c_void, t13: *const c_void, r1: *const c_void, r2: *const c_void, r3: *const c_void, p1: *const c_void, p2: *const c_void, p3: *const c_void, q: *const c_void, alpha: f64, new_img_size: *const core::Size, roi1: *mut core::Rect, roi2: *mut core::Rect, flags: i32, ocvrs_return: *mut Result<f32>);
	// reprojectImageTo3D(cv::InputArray, cv::OutputArray, cv::InputArray, bool, int) /usr/include/opencv2/calib3d.hpp:2948
	pub fn cv_reprojectImageTo3D_const__InputArrayR_const__OutputArrayR_const__InputArrayR_bool_int(disparity: *const c_void, _3d_image: *const c_void, q: *const c_void, handle_missing_values: bool, ddepth: i32, ocvrs_return: *mut Result_void);
	// sampsonDistance(cv::InputArray, cv::InputArray, cv::InputArray) /usr/include/opencv2/calib3d.hpp:2970
	pub fn cv_sampsonDistance_const__InputArrayR_const__InputArrayR_const__InputArrayR(pt1: *const c_void, pt2: *const c_void, f: *const c_void, ocvrs_return: *mut Result<f64>);
	// solveP3P(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, int) /usr/include/opencv2/calib3d.hpp:1055
	pub fn cv_solveP3P_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, ocvrs_return: *mut Result<i32>);
	// solvePnPGeneric(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArrayOfArrays, cv::OutputArrayOfArrays, bool, cv::SolvePnPMethod, cv::InputArray, cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:1193
	pub fn cv_solvePnPGeneric_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_SolvePnPMethod_const__InputArrayR_const__InputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, use_extrinsic_guess: bool, flags: crate::calib3d::SolvePnPMethod, rvec: *const c_void, tvec: *const c_void, reprojection_error: *const c_void, ocvrs_return: *mut Result<i32>);
	// solvePnPRansac(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool, int, float, double, cv::OutputArray, int) /usr/include/opencv2/calib3d.hpp:1011
	pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_int_float_double_const__OutputArrayR_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, confidence: f64, inliers: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
	// solvePnPRansac(cv::InputArray, cv::InputArray, cv::InputOutputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, const cv::UsacParams &) /usr/include/opencv2/calib3d.hpp:1023
	pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const_UsacParamsR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, inliers: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<bool>);
	// solvePnPRefineLM(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputOutputArray, cv::InputOutputArray, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1084
	pub fn cv_solvePnPRefineLM_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_TermCriteria(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
	// solvePnPRefineVVS(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputOutputArray, cv::InputOutputArray, cv::TermCriteria, double) /usr/include/opencv2/calib3d.hpp:1115
	pub fn cv_solvePnPRefineVVS_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_TermCriteria_double(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, criteria: *const core::TermCriteria, vv_slambda: f64, ocvrs_return: *mut Result_void);
	// solvePnP(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, bool, int) /usr/include/opencv2/calib3d.hpp:963
	pub fn cv_solvePnP_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, flags: i32, ocvrs_return: *mut Result<bool>);
	// stereoCalibrate(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputOutputArray, cv::InputOutputArray, cv::InputOutputArray, cv::InputOutputArray, cv::Size, cv::InputOutputArray, cv::InputOutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1843
	pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// stereoCalibrate(cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputArrayOfArrays, cv::InputOutputArray, cv::InputOutputArray, cv::InputOutputArray, cv::InputOutputArray, cv::Size, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:1852
	pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
	// stereoRectifyUncalibrated(cv::InputArray, cv::InputArray, cv::InputArray, cv::Size, cv::OutputArray, cv::OutputArray, double) /usr/include/opencv2/calib3d.hpp:2003
	pub fn cv_stereoRectifyUncalibrated_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__OutputArrayR_const__OutputArrayR_double(points1: *const c_void, points2: *const c_void, f: *const c_void, img_size: *const core::Size, h1: *const c_void, h2: *const c_void, threshold: f64, ocvrs_return: *mut Result<bool>);
	// stereoRectify(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::Size, cv::InputArray, cv::InputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, cv::OutputArray, int, double, cv::Size, cv::Rect *, cv::Rect *) /usr/include/opencv2/calib3d.hpp:1965
	pub fn cv_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_double_Size_RectX_RectX(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, alpha: f64, new_image_size: *const core::Size, valid_pix_roi1: *mut core::Rect, valid_pix_roi2: *mut core::Rect, ocvrs_return: *mut Result_void);
	// triangulatePoints(cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:2861
	pub fn cv_triangulatePoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(proj_matr1: *const c_void, proj_matr2: *const c_void, proj_points1: *const c_void, proj_points2: *const c_void, points4_d: *const c_void, ocvrs_return: *mut Result_void);
	// undistortImagePoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:3738
	pub fn cv_undistortImagePoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, unnamed: *const core::TermCriteria, ocvrs_return: *mut Result_void);
	// undistortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray) /usr/include/opencv2/calib3d.hpp:3717
	pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, p: *const c_void, ocvrs_return: *mut Result_void);
	// undistortPoints(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::InputArray, cv::TermCriteria) /usr/include/opencv2/calib3d.hpp:3724
	pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, p: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
	// undistort(cv::InputArray, cv::OutputArray, cv::InputArray, cv::InputArray, cv::InputArray) /usr/include/opencv2/calib3d.hpp:3491
	pub fn cv_undistort_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, new_camera_matrix: *const c_void, ocvrs_return: *mut Result_void);
	// validateDisparity(cv::InputOutputArray, cv::InputArray, int, int, int) /usr/include/opencv2/calib3d.hpp:2905
	pub fn cv_validateDisparity_const__InputOutputArrayR_const__InputArrayR_int_int_int(disparity: *const c_void, cost: *const c_void, min_disparity: i32, number_of_disparities: i32, disp12_max_disp: i32, ocvrs_return: *mut Result_void);
	// CirclesGridFinderParameters() /usr/include/opencv2/calib3d.hpp:1411
	pub fn cv_CirclesGridFinderParameters_CirclesGridFinderParameters(ocvrs_return: *mut Result<crate::calib3d::CirclesGridFinderParameters>);
	// run(cv::InputOutputArray) /usr/include/opencv2/calib3d.hpp:644
	pub fn cv_LMSolver_run_const_const__InputOutputArrayR(instance: *const c_void, param: *const c_void, ocvrs_return: *mut Result<i32>);
	// setMaxIters(int) /usr/include/opencv2/calib3d.hpp:650
	pub fn cv_LMSolver_setMaxIters_int(instance: *mut c_void, max_iters: i32, ocvrs_return: *mut Result_void);
	// getMaxIters() /usr/include/opencv2/calib3d.hpp:654
	pub fn cv_LMSolver_getMaxIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// create(const Ptr<LMSolver::Callback> &, int) /usr/include/opencv2/calib3d.hpp:663
	pub fn cv_LMSolver_create_const_Ptr_Callback_R_int(cb: *const c_void, max_iters: i32, ocvrs_return: *mut Result<*mut c_void>);
	// create(const Ptr<LMSolver::Callback> &, int, double) /usr/include/opencv2/calib3d.hpp:664
	pub fn cv_LMSolver_create_const_Ptr_Callback_R_int_double(cb: *const c_void, max_iters: i32, eps: f64, ocvrs_return: *mut Result<*mut c_void>);
	// compute(cv::InputArray, cv::OutputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:629
	pub fn cv_LMSolver_Callback_compute_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, param: *const c_void, err: *const c_void, j: *const c_void, ocvrs_return: *mut Result<bool>);
	// getPreFilterType() /usr/include/opencv2/calib3d.hpp:3326
	pub fn cv_StereoBM_getPreFilterType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setPreFilterType(int) /usr/include/opencv2/calib3d.hpp:3327
	pub fn cv_StereoBM_setPreFilterType_int(instance: *mut c_void, pre_filter_type: i32, ocvrs_return: *mut Result_void);
	// getPreFilterSize() /usr/include/opencv2/calib3d.hpp:3329
	pub fn cv_StereoBM_getPreFilterSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setPreFilterSize(int) /usr/include/opencv2/calib3d.hpp:3330
	pub fn cv_StereoBM_setPreFilterSize_int(instance: *mut c_void, pre_filter_size: i32, ocvrs_return: *mut Result_void);
	// getPreFilterCap() /usr/include/opencv2/calib3d.hpp:3332
	pub fn cv_StereoBM_getPreFilterCap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setPreFilterCap(int) /usr/include/opencv2/calib3d.hpp:3333
	pub fn cv_StereoBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32, ocvrs_return: *mut Result_void);
	// getTextureThreshold() /usr/include/opencv2/calib3d.hpp:3335
	pub fn cv_StereoBM_getTextureThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setTextureThreshold(int) /usr/include/opencv2/calib3d.hpp:3336
	pub fn cv_StereoBM_setTextureThreshold_int(instance: *mut c_void, texture_threshold: i32, ocvrs_return: *mut Result_void);
	// getUniquenessRatio() /usr/include/opencv2/calib3d.hpp:3338
	pub fn cv_StereoBM_getUniquenessRatio_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setUniquenessRatio(int) /usr/include/opencv2/calib3d.hpp:3339
	pub fn cv_StereoBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32, ocvrs_return: *mut Result_void);
	// getSmallerBlockSize() /usr/include/opencv2/calib3d.hpp:3341
	pub fn cv_StereoBM_getSmallerBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setSmallerBlockSize(int) /usr/include/opencv2/calib3d.hpp:3342
	pub fn cv_StereoBM_setSmallerBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
	// getROI1() /usr/include/opencv2/calib3d.hpp:3344
	pub fn cv_StereoBM_getROI1_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
	// setROI1(cv::Rect) /usr/include/opencv2/calib3d.hpp:3345
	pub fn cv_StereoBM_setROI1_Rect(instance: *mut c_void, roi1: *const core::Rect, ocvrs_return: *mut Result_void);
	// getROI2() /usr/include/opencv2/calib3d.hpp:3347
	pub fn cv_StereoBM_getROI2_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
	// setROI2(cv::Rect) /usr/include/opencv2/calib3d.hpp:3348
	pub fn cv_StereoBM_setROI2_Rect(instance: *mut c_void, roi2: *const core::Rect, ocvrs_return: *mut Result_void);
	// create(int, int) /usr/include/opencv2/calib3d.hpp:3363
	pub fn cv_StereoBM_create_int_int(num_disparities: i32, block_size: i32, ocvrs_return: *mut Result<*mut c_void>);
	// compute(cv::InputArray, cv::InputArray, cv::OutputArray) /usr/include/opencv2/calib3d.hpp:3293
	pub fn cv_StereoMatcher_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, ocvrs_return: *mut Result_void);
	// getMinDisparity() /usr/include/opencv2/calib3d.hpp:3296
	pub fn cv_StereoMatcher_getMinDisparity_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setMinDisparity(int) /usr/include/opencv2/calib3d.hpp:3297
	pub fn cv_StereoMatcher_setMinDisparity_int(instance: *mut c_void, min_disparity: i32, ocvrs_return: *mut Result_void);
	// getNumDisparities() /usr/include/opencv2/calib3d.hpp:3299
	pub fn cv_StereoMatcher_getNumDisparities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setNumDisparities(int) /usr/include/opencv2/calib3d.hpp:3300
	pub fn cv_StereoMatcher_setNumDisparities_int(instance: *mut c_void, num_disparities: i32, ocvrs_return: *mut Result_void);
	// getBlockSize() /usr/include/opencv2/calib3d.hpp:3302
	pub fn cv_StereoMatcher_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setBlockSize(int) /usr/include/opencv2/calib3d.hpp:3303
	pub fn cv_StereoMatcher_setBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
	// getSpeckleWindowSize() /usr/include/opencv2/calib3d.hpp:3305
	pub fn cv_StereoMatcher_getSpeckleWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setSpeckleWindowSize(int) /usr/include/opencv2/calib3d.hpp:3306
	pub fn cv_StereoMatcher_setSpeckleWindowSize_int(instance: *mut c_void, speckle_window_size: i32, ocvrs_return: *mut Result_void);
	// getSpeckleRange() /usr/include/opencv2/calib3d.hpp:3308
	pub fn cv_StereoMatcher_getSpeckleRange_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setSpeckleRange(int) /usr/include/opencv2/calib3d.hpp:3309
	pub fn cv_StereoMatcher_setSpeckleRange_int(instance: *mut c_void, speckle_range: i32, ocvrs_return: *mut Result_void);
	// getDisp12MaxDiff() /usr/include/opencv2/calib3d.hpp:3311
	pub fn cv_StereoMatcher_getDisp12MaxDiff_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setDisp12MaxDiff(int) /usr/include/opencv2/calib3d.hpp:3312
	pub fn cv_StereoMatcher_setDisp12MaxDiff_int(instance: *mut c_void, disp12_max_diff: i32, ocvrs_return: *mut Result_void);
	// getPreFilterCap() /usr/include/opencv2/calib3d.hpp:3395
	pub fn cv_StereoSGBM_getPreFilterCap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setPreFilterCap(int) /usr/include/opencv2/calib3d.hpp:3396
	pub fn cv_StereoSGBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32, ocvrs_return: *mut Result_void);
	// getUniquenessRatio() /usr/include/opencv2/calib3d.hpp:3398
	pub fn cv_StereoSGBM_getUniquenessRatio_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setUniquenessRatio(int) /usr/include/opencv2/calib3d.hpp:3399
	pub fn cv_StereoSGBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32, ocvrs_return: *mut Result_void);
	// getP1() /usr/include/opencv2/calib3d.hpp:3401
	pub fn cv_StereoSGBM_getP1_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setP1(int) /usr/include/opencv2/calib3d.hpp:3402
	pub fn cv_StereoSGBM_setP1_int(instance: *mut c_void, p1: i32, ocvrs_return: *mut Result_void);
	// getP2() /usr/include/opencv2/calib3d.hpp:3404
	pub fn cv_StereoSGBM_getP2_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setP2(int) /usr/include/opencv2/calib3d.hpp:3405
	pub fn cv_StereoSGBM_setP2_int(instance: *mut c_void, p2: i32, ocvrs_return: *mut Result_void);
	// getMode() /usr/include/opencv2/calib3d.hpp:3407
	pub fn cv_StereoSGBM_getMode_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
	// setMode(int) /usr/include/opencv2/calib3d.hpp:3408
	pub fn cv_StereoSGBM_setMode_int(instance: *mut c_void, mode: i32, ocvrs_return: *mut Result_void);
	// create(int, int, int, int, int, int, int, int, int, int, int) /usr/include/opencv2/calib3d.hpp:3447
	pub fn cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int(min_disparity: i32, num_disparities: i32, block_size: i32, p1: i32, p2: i32, disp12_max_diff: i32, pre_filter_cap: i32, uniqueness_ratio: i32, speckle_window_size: i32, speckle_range: i32, mode: i32, ocvrs_return: *mut Result<*mut c_void>);
	// UsacParams() /usr/include/opencv2/calib3d.hpp:560
	pub fn cv_UsacParams_UsacParams(ocvrs_return: *mut Result<crate::calib3d::UsacParams>);
}
